# *CTF 2023 - GoGPT

## Reverse

As the challenge is written in `Golang`, it left me with a piece of shit in my IDA pro 7.5 without any plugins to recover the symbol table of the binary file at the very beginning. Luckily as the IDA Free has supportted reversing the `Golang` binary file, I can identify the core logic easily.

The entry point for a `Golang` binary file is `main.main()`, at the very beginning a string `"cH@t_GpT_15_h3R3"` was passed into the function `main.shuffle()`:

```c
// main.main
void __fastcall main_main()
{
  //...
  qmemcpy(v52, "cH@t_GpT_15_h3R3", sizeof(v52));
  v54 = main_shuffle((unsigned int)v52, 16, 16, v0, v1, v2, v3);
```

In `main.shuffle()`, a copy of the string was made by `runtime_mallocgc()` and `runtime_memmove()` (as the implementation of `Golang` still remains unknown for me, I can only guess like that). Then the seed of a random number generator was initialized, and a loop was used to do the traverse on the copy of the string and exchange the bytes under the index generated by the random number generator.

```c
// main.shuffle
__int64 __golang main_shuffle(
        __int64 a1,
        unsigned __int64 a2,
        __int64 a3,
        __int64 a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9)
{
  __int64 v9; // r14
  __int64 i; // rdx
  unsigned __int64 v11; // rax
  char v12; // si
  __int64 v14; // [rsp+0h] [rbp-18h]
  __int64 v15; // [rsp+8h] [rbp-10h]
  void *retaddr; // [rsp+18h] [rbp+0h] BYREF
  __int64 v17; // [rsp+20h] [rbp+8h]
  __int64 v18; // [rsp+20h] [rbp+8h]
  __int64 v19; // [rsp+30h] [rbp+18h]

  while ( (unsigned __int64)&retaddr <= *(_QWORD *)(v9 + 16) )
  {
    v18 = a1;
    v19 = a3;
    runtime_morestack_noctxt();
    a1 = v18;
    a3 = v19;
  }
  v17 = a1;
  v15 = runtime_mallocgc(a2, 0, 0, a4, a5, a6, a7, a8, a9);
  runtime_memmove(v15, v17, a2);
  math_rand__ptr_Rand_Seed(qword_569110, 34LL);
  for ( i = a2 - 1; i > 0; i = v14 - 1 )
  {
    v14 = i;
    v11 = math_rand__ptr_Rand_Intn(qword_569110, i + 1);
    v12 = *(_BYTE *)(v14 + v15);
    if ( v11 >= a2 )
      runtime_panicIndex(v11, a2, a2, a4);
    a4 = *(unsigned __int8 *)(v11 + v15);
    *(_BYTE *)(v15 + v14) = a4;
    *(_BYTE *)(v15 + v11) = v12;
  }
  return v15;
}
```

As the seed is a static value `34`, we can get the output string simply like this:

```go
package main

import (
    "math/rand"
    "fmt"
)

func main() {
    s := []byte("cH@t_GpT_15_h3R3")

    rand.Seed(34)

    for i := len(s) - 1; i >= 0; i-- {
	j := rand.Intn(i + 1)
	s[i], s[j] = s[j], s[i]
    }

    fmt.Printf("%s\n", s)
}
```

Then we can get a static output string:

![image.png](https://s2.loli.net/2023/08/04/bDi4GT7OgCqXhE5.png)

Backing to the `main.main()`, it's just like a normal reverse challenge: read the flag and do the verification. The length of the flag is `32`:

```c
  fmt_Fscanf(
    (unsigned int)off_4E1F88,
    qword_569128,
    (unsigned int)"%s\n",
    3,
    (unsigned int)v60,
    1,
    1,
    v8,
    v9,
    v34,
    v40,
    v46,
    v51);
  ptr = v56->ptr;
  if ( v56->len == 32 )
  {
```

Then it comes rto a encryption logic, here the `v24` is the string we get from the `main.shuffle()`, and the `v19` and `v25` seem to be the copies of flag we input? The logic is very simple that it does a `xor` between two strings here:

```c
    v24 = v54;
    v25 = v55;
    for ( i = 0LL; (__int64)ptr > i; ++i )
    {
      v21 = (int)ptr;
      if ( (unsigned __int64)(i % 16) >= 0x10 )
        runtime_panicIndex(i % 16, v19, 16LL, v24);
      v22 = *(unsigned __int8 *)(v24 + i % 16);
      v20 = v22 ^ *(unsigned __int8 *)(v25 + i);
      *(_BYTE *)(v19 + i) = v20;
    }
```

Finally it'll be encoded with `base64` and be compared with another string:

```c
    v27 = v19;
    v28 = encoding_base64__ptr_Encoding_EncodeToString(
            qword_568F70,
            v19,
            v23,
            v23,
            qword_568F70,
            v25,
            v20,
            v21,
            v22,
            v37,
            v43,
            v49);
    if ( v27 == 44 && (unsigned __int8)runtime_memequal(v28, "fiAGBkgXN3McFy9hAHRfCwYaIjQCRDFsXC8ZYBFmEDU=", 44LL) )
    {
      v58[0] = &RTYPE_string;
      v58[1] = &off_4E1A08;
      fmt_Fprintln((unsigned int)off_4E1FA8, qword_569130, (unsigned int)v58, 1, 1, v29, v30, v31, v32, v38, v44, v50);
    }
```

## Solution

As the logic is clear to us, we can now easily give out the solution:

```python
import base64

def main():
    s = b"fiAGBkgXN3McFy9hAHRfCwYaIjQCRDFsXC8ZYBFmEDU="
    b = b"TcR@3t_3hp_5_G1H"
    s = base64.b64decode(s)
    for i in range(len(s)):
        print(chr(s[i] ^ b[i % 16]), end = '')
    print("")

if __name__ == '__main__':
    main()
```

Then we'll get the flag:

![image.png](https://s2.loli.net/2023/08/04/OFnSylsXEv4oUhp.png)

## Finally 

As the official writeup says, the challenge is written by the ChatGPT, but I don't think that does really make sense...
